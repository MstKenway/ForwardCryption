A file to restore something unneed

    ///function for batch authorisation

//    void Cergen_Bathch();

//    void init_subue(SUBUE &subue);

//    void free_subue(SUBUE &subue);

//    bool Pverify(SUBUE &subue);

//    int Poly(element_t &S, element_t &U_gamma, element_t &T_gamma, element_t &pk_gamma, element_t &h_gamma);

//    int uen_2_satellite_launch(const std::string &addr, unsigned short port, bool isPoly);

//    int Sverify(element_t &id_st, element_t &m_st, element_t &s_st, element_t &U_st, element_t &pk_st, element_t &T_st);


    // int DecryptSCert(element_t Qi);

//    int SCertVerify(std::vector<UE> &ue_list, Sateillite &sateillite, element_t Ppub);
//    int
//    SCertVerifyforSwith(element_t Q1i, element_t Q2i, element_t V2i, element_t Sign4Others_i, Sateillite &sateillite2);





















//
///// generate certification for batch authorisation
///// \return
//void UE::Cergen_Bathch() {
//    system_clock::time_point begintime, endtime;
//    std::cout << "UE generate certificate for batch authorisation...";
//    begintime = system_clock::now();
//    ///definition
//    element_t ua, ub;
//    element_t theta;
//    element_t q1, q2, q3;
//
//
//    ///initializing
//    element_init_Zr(ua, pairing);
//    element_init_Zr(ub, pairing);
//    element_init_Zr(theta, pairing);
//    element_init_G1(q1, pairing);
//    element_init_G1(q2, pairing);
//    element_init_Zr(q3, pairing);
//
//
//    element_random(theta);
//    element_add(m, id, theta);
//
//    element_random(ua);
//    element_random(ub);
//    element_pow_zn(q1, g, ua);
//    element_pow_zn(q2, g, ub);
//    element_pow_zn(q2, q2, SK_help);
//    element_mul(U, q1, q2);
//
//    element_mul(q3, ub, SK_help);
//    element_add(q3, q3, SK_help);
//    element_add(q3, q3, ua);
//
//    unsigned char m_string[element_length_in_bytes(m)];
//    unsigned char U_string[element_length_in_bytes(U)];
//    unsigned char pk_string[element_length_in_bytes(pk)];
//    unsigned char T_string[element_length_in_bytes(T)];
//    element_to_bytes(m_string, m);
//    element_to_bytes(U_string, U);
//    element_to_bytes(pk_string, pk);
//    element_to_bytes(T_string, T);
//    std::string temp = Utils::myxor((const char *) m_string, (const char *) U_string);
//    temp = Utils::myxor(temp, (const char *) pk_string);
//    temp = Utils::myxor(temp, (const char *) T_string);
//
//
//    element_from_hash(gamma, (void *) temp.c_str(), temp.length());
//
//    element_mul(s, gamma, q3);
//
//    element_pow_zn(Tn_gamma, T, gamma);
//    element_pow_zn(pkn_gamma, pk, gamma);
//    element_pow_zn(Un_gamma, U, gamma);
//    element_set0(hn_gamma);
//
//    element_mul(hn_gamma, h, gamma);
//
//    endtime = system_clock::now();
//    batch_cer_gen_time = duration<double, milli>(endtime - begintime).count();
//    std::cout << "SUCCESS\n";
//
//    ///free memory
//    end:
//    element_clear(ua);
//    element_clear(ub);
//    element_clear(theta);
//    element_clear(q1);
//    element_clear(q2);
//    element_clear(q3);
//}
//
///// Receive two arrays from ue. G1_array is U, pk, T, Tn_gamma, pkn_gamma, Un_gamma, hn_gamma
///// Zr_array is id, m, s, h
///// \param port
//[[noreturn]]void UE::accept_new_ue(unsigned short port) {
//    system_clock::time_point begintime, endtime;
//    int len = 0;
//    char ret = 0;
//    int socket_fd, client_fd;
//    sockaddr_in addr;
//    ///bind and listen local port
//    socket_fd = auth_listen(UEN_VRF_UE_PORT);
//    if (socket_fd < 0) {
//        perror("UE listen error:");
//        exit(1);
//    }
//
//    while (isReady) {
//        ///wait for new connection
//        client_fd = auth_accept(socket_fd, addr);
//        if (client_fd < 0) {
//            perror("Ue accept error:");
//            goto end;
//        }
//        int G1_num, Zr_num;
//        element_t *G1_res, *Zr_res;
//        G1_num = 0;
//        Zr_num = 0;
//        G1_res = Zr_res = nullptr;
//        /// first, recv data to verify ue
//        ///rec  G1_array is U, pk, T, Tn_gamma, pkn_gamma, Un_gamma
//        /// Zr_array is id, m, s, h, hn_gamma
//        begintime = system_clock::now();
//        auth_recv(client_fd, G1_num, Zr_num, &G1_res, &Zr_res, pairing);
//        if (G1_num != 6 || Zr_num != 5) {
//            perror("Ue recv element number error:");
//            goto free_recv;
//        }
//        endtime = system_clock::now();
//        comm_uei_time = duration<double, milli>(endtime - begintime).count();
//
//        ///unzip
//        SUBUE subue;
//        init_subue(subue);
//        element_set(subue.U, G1_res[0]);
//        element_set(subue.pk, G1_res[1]);
//        element_set(subue.T, G1_res[2]);
//        element_set(subue.Tn_gamma, G1_res[3]);
//        element_set(subue.Un_gamma, G1_res[4]);
//        element_set(subue.pkn_gamma, G1_res[5]);
//
//        element_set(subue.id, Zr_res[0]);
//        element_set(subue.m, Zr_res[1]);
//        element_set(subue.s, Zr_res[2]);
//        element_set(subue.h, Zr_res[3]);
//        element_set(subue.hn_gamma, Zr_res[4]);
//
//        ///verify ue
//        len = Pverify(subue);
//
//        begintime = system_clock::now();
//        if (len < 0) {
//            printf("Ue certificate verify FAIL!\n");
//            free_subue(subue);
//            ret = 0;
//            send(client_fd, &ret, 1, 0);
//        } else {
//            printf("Ue certificate verify SUCCESS!\n");
//            ret = 1;
//            send(client_fd, &ret, 1, 0);
//        }
//        endtime = system_clock::now();
//        comm_uei_time += duration<double, milli>(endtime - begintime).count();
//
//        free_recv:
//        for (int i = 0; i < G1_num; ++i) {
//            element_clear(G1_res[i]);
//        }
//        for (int i = 0; i < Zr_num; ++i) {
//            element_clear(Zr_res[i]);
//        }
//        end:
//        auth_close(client_fd);
//        batch_uei_ver_count++;
//        total_uei_comm_time += comm_uei_time;
//        wst_uei_comm_time = comm_uei_time > wst_uei_comm_time ? comm_uei_time : wst_uei_comm_time;
//        ///output
//        cur_uei_data.clear();
//        cur_uei_data.push_back(VOIDDATA{DOUBLE, 0, uei_ver_time});
//        cur_uei_data.push_back(VOIDDATA{DOUBLE, 0, comm_uei_time});
//        cur_uei_data.push_back(VOIDDATA{DOUBLE, 0, uei_ver_time + comm_uei_time});
//        draw_table(UE_BATCH_UEI_CUR_TIME_COST_LABEL, lb_ue_batch_uei_cur_time_cost, cur_uei_data);
//
//        avg_uei_data.clear();
//        avg_uei_data.push_back(VOIDDATA{INT, (int) batch_uei_ver_count});
//        avg_uei_data.push_back(VOIDDATA{DOUBLE, 0, total_uei_ver_time / batch_uei_ver_count});
//        avg_uei_data.push_back(VOIDDATA{DOUBLE, 0, total_uei_comm_time / batch_uei_ver_count});
//        avg_uei_data.push_back(
//                VOIDDATA{DOUBLE, 0, (total_uei_ver_time + total_uei_comm_time) / batch_uei_ver_count});
//        draw_table(UE_BATCH_UEI_AVG_TIME_COST_LABEL, lb_ue_batch_uei_avg_time_cost, avg_uei_data);
//
//        wst_uei_data.clear();
//        wst_uei_data.push_back(VOIDDATA{DOUBLE, 0, wst_uei_ver_time});
//        wst_uei_data.push_back(VOIDDATA{DOUBLE, 0, wst_uei_comm_time});
//        wst_uei_data.push_back(VOIDDATA{DOUBLE, 0, wst_uei_ver_time + wst_uei_comm_time});
//        draw_table(UE_BATCH_UEI_WST_TIME_COST_LABEL, lb_ue_batch_uei_wst_time_cost, wst_uei_data);
//    }
//    auth_close(socket_fd);
//}

///// Send two arrays to uen.G1_array is U, pk, T, Tn_gamma, pkn_gamma, Un_gamma, hn_gamma
///// Zr_array is id, m, s, h
///// \param addr
///// \param port
//void UE::uen_luanch(const std::string &addr, unsigned short port) {
//    int len = 0;
//    char ret = 0;
//    int conn_fd;
//    conn_fd = auth_connect(addr, port);
//    if (conn_fd < 0) {
//        perror("UE conn error:");
//    }
//    ///send data to server
//    ///define 2 G1 array and initialize the same as pk and T (while data won't be copied)
//    element_t G1_req[6], Zr_req[5];
//    for (auto &i : G1_req) {
//        element_init_G1(i, pairing);
//    }
//    for (auto &i : Zr_req) {
//        element_init_Zr(i, pairing);
//    }
//    ///now set the data of the array
//    element_set(G1_req[0], U);
//    element_set(G1_req[1], pk);
//    element_set(G1_req[2], T);
//    element_set(G1_req[3], Tn_gamma);
//    element_set(G1_req[4], pkn_gamma);
//    element_set(G1_req[5], Un_gamma);
//
//    element_set(Zr_req[0], id);
//    element_set(Zr_req[1], m);
//    element_set(Zr_req[2], s);
//    element_set(Zr_req[3], h);
//    element_set(Zr_req[4], hn_gamma);
//
//
//    ///send G1 array and Zr array
//    len = auth_send(conn_fd, 6, 5, G1_req, Zr_req);
//
//    ///free the memory of the array
//    for (auto &i : G1_req) {
//        element_clear(i);
//    }
//    for (auto &i : Zr_req) {
//        element_clear(i);
//    }
//    if (len < 0) {
//        perror("UE send error");
//        goto end;
//    }
//    ///recv result
//    len = recv(conn_fd, &ret, 1, 0);
//    if (len < 0) {
//        exit(1);
//    }
//    if (ret == 1) {
//        printf("uen verification success!\n");
//    } else {
//        printf("uen verification failed!\n");
//    }
//    end:
//    auth_close(conn_fd);
//}
//
//
///// initialize SUBUE, all property is id,m, U, pk, T, s, h, Tn_gamma, pkn_gamma, Un_gamma, hn_gamma;
///// \param subue To be initialized
//void UE::init_subue(SUBUE &subue) {
//    element_init_Zr(subue.id, pairing);
//    element_init_Zr(subue.m, pairing);
//    element_init_G1(subue.U, pairing);
//    element_init_G1(subue.pk, pairing);
//    element_init_G1(subue.T, pairing);
//    element_init_Zr(subue.s, pairing);
//    element_init_Zr(subue.h, pairing);
//    element_init_G1(subue.Tn_gamma, pairing);
//    element_init_G1(subue.pkn_gamma, pairing);
//    element_init_G1(subue.Un_gamma, pairing);
//    element_init_Zr(subue.hn_gamma, pairing);
//}
//
///// free all memory in subue
///// \param subue To be free
//void UE::free_subue(SUBUE &subue) {
//    element_clear(subue.id);
//    element_clear(subue.m);
//    element_clear(subue.U);
//    element_clear(subue.pk);
//    element_clear(subue.T);
//    element_clear(subue.s);
//    element_clear(subue.h);
//    element_clear(subue.Tn_gamma);
//    element_clear(subue.pkn_gamma);
//    element_clear(subue.Un_gamma);
//    element_clear(subue.hn_gamma);
//}
//
//
///// verify the info subue
///// \return -1 as error or 0 as success
//bool UE::Pverify(SUBUE &subue) {
//    system_clock::time_point begintime, endtime;
//    bool ret = true;
//    std::cout << "UEN verify uei...";
//    begintime = system_clock::now();
//
//    ///definition
//    element_t gamma_temp;
//    element_t h_temp;
//    element_t q, q_inv;
//
//    ///initialize
//    element_init_Zr(gamma_temp, pairing);
//    element_init_Zr(h_temp, pairing);
//    element_init_G1(q, pairing);
//    element_init_G1(q_inv, pairing);
//
//    unsigned char m_string[element_length_in_bytes(subue.m)];
//    unsigned char U_string[element_length_in_bytes(subue.U)];
//    unsigned char pk_string[element_length_in_bytes(subue.pk)];
//    unsigned char T_string[element_length_in_bytes(subue.T)];
//    element_to_bytes(m_string, subue.m);
//    element_to_bytes(U_string, subue.U);
//    element_to_bytes(pk_string, subue.pk);
//    element_to_bytes(T_string, subue.T);
//
//    std::string temp = Utils::myxor((const char *) m_string, (const char *) U_string);
//    temp = Utils::myxor(temp, (const char *) pk_string);
//    temp = Utils::myxor(temp, (const char *) T_string);
//
//    element_from_hash(gamma_temp, (void *) temp.c_str(), temp.length());
//
//
//    unsigned char id_string[element_length_in_bytes(subue.id)];
//    element_to_bytes(id_string, subue.id);
//    temp = Utils::myxor((const char *) pk_string, (const char *) id_string);
//    element_from_hash(h_temp, (void *) temp.c_str(), temp.length());
//
//    element_pow_zn(q, Ppub, h_temp);
//    element_mul(q, q, subue.T);
//    element_mul(q, q, subue.pk);
//    element_mul(q, q, subue.U);
//
//    element_pow_zn(q, q, gamma_temp);
//    element_pow_zn(q_inv, g, subue.s);
//
//    bool isVerify = !element_cmp(q, q_inv);
//    if (isVerify) {
//        std::cout << "Partially Verification  Succeed!" << std::endl;
//        ue_list.push_back(subue);
//    } else {
//        std::cout << "Error Partially Verification Failed! " << std::endl;
//        ret = false;
//    }
//
//
//    endtime = system_clock::now();
//    uei_ver_time = duration<double, milli>(endtime - begintime).count();
//    total_uei_ver_time += uei_ver_time;
//    wst_uei_ver_time = uei_ver_time > wst_uei_ver_time ? uei_ver_time : wst_uei_ver_time;
//    ///free
//    element_clear(gamma_temp);
//    element_clear(h_temp);
//    element_clear(q);
//    element_clear(q_inv);
//
//    return ret;
//}
//
//
//int UE::uen_2_satellite_launch(const std::string &addr, unsigned short port, bool isPoly) {
//    system_clock::time_point begintime, endtime;
//    ///send Zr: S, h_gamma, s, id, hn_gamma
//    ///send G1: T_gamma, pk_gamma, U_gamma, pkn_gamma, Tn_gamma, Un_gamma
//    ///verify the return value from satellite
//    ///first, compute
//    int len = 0, ret = 0;
//    int conn_fd;
//    conn_fd = auth_connect(addr, port);
//    if (conn_fd < 0) {
//        perror("UE conn error:");
//        return -1;
//    }
//    ///send data to server
//    ///define
//    element_t G1_req[6], Zr_req[5];
//    for (auto &i : G1_req) {
//        element_init_G1(i, pairing);
//    }
//    for (auto &i : Zr_req) {
//        element_init_Zr(i, pairing);
//    }
//    ///now set the data of the array
//    ///U_gamma, T_gamma, pk_gamma, Tn_gamma, pkn_gamma, Un_gamma
//    ///id, S, h_gamma, s, hn_gamma
//
//    //S,U_gamma,T_gamma,pk_gamma,h_gamma
//    batch_poly_time = 0;
//    if (isPoly)
//        Poly(Zr_req[1], G1_req[0], G1_req[1], G1_req[2], Zr_req[2]);
//    element_set(G1_req[3], Tn_gamma);
//    element_set(G1_req[4], pkn_gamma);
//    element_set(G1_req[5], Un_gamma);
//
//    element_set(Zr_req[0], id);
//    element_set(Zr_req[3], s);
//    element_set(Zr_req[4], hn_gamma);
//
//    begintime = system_clock::now();
//    ///send G1 array with pk and T, and one Zr h
//    len = auth_send(conn_fd, 6, 5, G1_req, Zr_req);
//
//    ///free the memory of the array
//    for (auto &i : G1_req) {
//        element_clear(i);
//    }
//    for (auto &i : Zr_req) {
//        element_clear(i);
//    }
//    if (len < 0) {
//        perror("UE send error");
//        goto end;
//    }
//
//    ///recv and verify satellite
//    int G1_num, Zr_num;
//    G1_num = 0;
//    Zr_num = 0;
//    element_t *G1_res, *Zr_res;
//    ///rec id,m,s and U, pk, T
//    auth_recv(conn_fd, G1_num, Zr_num, &G1_res, &Zr_res, pairing);
//    if (G1_num != 3 || Zr_num != 3) {
//        perror("UE verify respond element number error:");
//        ret = -1;
//        goto free_recv;
//    }
//    endtime = system_clock::now();
//    comm_batch_response_time = duration<double, milli>(endtime - begintime).count();
//
//    ///verify
//    len = Sverify(Zr_res[0], Zr_res[1], Zr_res[2], G1_res[0], G1_res[1], G1_res[2]);
//
//    if (len < 0) {
//        ret = len;
//    }
//    ///free
//    free_recv:
//    for (int i = 0; i < G1_num; ++i) {
//        element_clear(G1_res[i]);
//    }
//    for (int i = 0; i < Zr_num; ++i) {
//        element_clear(Zr_res[i]);
//    }
//
//    end:
//    auth_close(conn_fd);
//    ///output
//    cur_batch_data.clear();
//    cur_batch_data.push_back(VOIDDATA{DOUBLE, 0, batch_poly_time});
//    cur_batch_data.push_back(VOIDDATA{DOUBLE, 0, batch_verify_time});
//    cur_batch_data.push_back(VOIDDATA{DOUBLE, 0, comm_batch_response_time});
//    cur_batch_data.push_back(VOIDDATA{DOUBLE, 0, batch_poly_time + batch_verify_time + comm_batch_response_time});
//    draw_table(UE_BATCH_CUR_TIME_COST_LABEL, lb_ue_batch_cur_time_cost, cur_batch_data);
//
//    return len;
//}
//
//int UE::Poly(element_t &S, element_t &U_gamma, element_t &T_gamma, element_t &pk_gamma, element_t &h_gamma) {
//    system_clock::time_point begintime, endtime;
//    int ret = 0;
//    std::cout << "UEN is grouping all uei...\n";
//    begintime = system_clock::now();
//
//    int size = ue_list.size();
//    printf("Current valid UE number is %d.\n", size);
//    for (int i = 0; i < size; i++) {
//
////        element_t element;
////        element_init_G1(element,pairing);
//
////        element_pow_zn(element,ue_list[i].T,ue_list[i].gamma);
//        element_mul(T_gamma, T_gamma, ue_list[i].Tn_gamma);
//
////        element_pow_zn(element,ue_list[i].pk,ue_list[i].gamma);
//        element_mul(pk_gamma, ue_list[i].pkn_gamma, pk_gamma);
//
////        element_pow_zn(element,ue_list[i].U,ue_list[i].gamma);
//        element_mul(U_gamma, ue_list[i].Un_gamma, U_gamma);
//
////        element_t help;
////        element_init_Zr(help,pairing);
////        element_mul(help,ue_list[i].h,ue_list[i].gamma);
////        element_printf("%B\n", h_gamma);
//        element_add(h_gamma, ue_list[i].hn_gamma, h_gamma);
//    }
//
//    for (int i = 0; i < size; i++) {
//        element_add(S, ue_list[i].s, S);
//    }
//    endtime = system_clock::now();
//    batch_poly_time = duration<double, milli>(endtime - begintime).count();
//    return ret;
//}
//
//
//int
//UE::Sverify(element_t &id_st, element_t &m_st, element_t &s_st, element_t &U_st, element_t &pk_st, element_t &T_st) {
//    system_clock::time_point begintime, endtime;
//    std::cout << "UE verify satellite by batch mode...";
//    begintime = system_clock::now();
//    int ret = 0;
//    ///definition
//    element_t gamma_temp;
//    element_t q, q_inv;
//    element_t h_temp;
//
//    ///initialize
//    element_init_Zr(gamma_temp, pairing);
//    element_init_G1(q, pairing);
//    element_init_G1(q_inv, pairing);
//    element_init_Zr(h_temp, pairing);
//
//
//    unsigned char m_string[element_length_in_bytes(m_st)];
//    unsigned char U_string[element_length_in_bytes(U_st)];
//    unsigned char pk_string[element_length_in_bytes(pk_st)];
//    unsigned char T_string[element_length_in_bytes(T_st)];
//    element_to_bytes(m_string, m_st);
//    element_to_bytes(U_string, U_st);
//    element_to_bytes(pk_string, pk_st);
//    element_to_bytes(T_string, T_st);
//
//    std::string temp = Utils::myxor((const char *) m_string, (const char *) U_string);
//    temp = Utils::myxor(temp, (const char *) pk_string);
//    temp = Utils::myxor(temp, (const char *) T_string);
//
//    element_from_hash(gamma_temp, (void *) temp.c_str(), temp.length());
//
//
//    unsigned char id_string[element_length_in_bytes(id_st)];
//    element_to_bytes(id_string, id_st);
//    temp = Utils::myxor((const char *) pk_string, (const char *) id_string);
//    element_from_hash(h_temp, (void *) temp.c_str(), temp.length());
//
//
//    element_pow_zn(q, Ppub, h_temp);
//    element_mul(q, q, T_st);
//    element_mul(q, q, pk_st);
//    element_mul(q, q, U_st);
//
//    element_pow_zn(q, q, gamma_temp);
//    element_pow_zn(q_inv, g, s_st);
//
//
//    bool isVerify = !element_cmp(q, q_inv);
//    if (isVerify) {
//        std::cout << "Verification for Sateillite Succeed!" << std::endl;
//    } else {
//        std::cout << "Verification for Sateillite" << std::endl;
//        ret = -1;
//    }
//
//    endtime = system_clock::now();
//    batch_verify_time = duration<double, milli>(endtime - begintime).count();
//
//    ///free
//    element_clear(gamma_temp);
//    element_clear(q);
//    element_clear(q_inv);
//    element_clear(h_temp);
//
//    return ret;
//}


// int UE::DecryptSCert(element_t Qi) {
//
//     system_clock::time_point begintime, endtime;
//     std::cout << "UEDecryptSCert\t";
//     begintime = system_clock::now();
//
//     element_init_G1(omega, pairing);
// //    element_init_G1(Qi,pairing);
//     element_pow_zn(omega, Qi, SK);
//
//     endtime = system_clock::now();
//     double clock_UEDecryptSCert;
//     clock_UEDecryptSCert = duration<double, milli>(endtime - begintime).count();
//     std::cout << clock_UEDecryptSCert * 1000 << "ms." << std::endl;
//
//     return 1;
// }

//
//int UE::SCertVerify(std::vector<UE> &ue_list, Sateillite &sateillite, element_t Ppub) {
//
//    system_clock::time_point begintime, endtime;
//    std::cout << "UESCertVerify\t";
//    begintime = system_clock::now();
//
//    element_t temp1, temp2;
//    element_init_G1(temp1, pairing);
//    element_init_G1(temp2, pairing);
//    element_set1(temp1);
//
//    int size = ue_list.size();
//    for (int i = 0; i < size; i++) {
//        element_mul(temp1, temp1, ue_list[i].omega);
//    }
//
//    element_pow_zn(temp2, Ppub, sateillite.h);
//    element_mul(temp2, temp2, sateillite.pk);
//    element_mul(temp2, temp2, sateillite.T);
//    element_pow_zn(temp2, temp2, sateillite.gamma);
//
//    bool isVerify = !element_cmp(temp1, temp2);
//    if (isVerify)
//        std::cout << "Verification for Satellite by Secret Sharing Succeed!" << std::endl;
//    else
//        std::cout << "Verification for Satellite by Secret Sharing Failure!" << std::endl;
//
//    endtime = system_clock::now();
//    double clock_UESCertVerify;
//    clock_UESCertVerify = duration<double, milli>(endtime - begintime).count();
//    std::cout << clock_UESCertVerify * 1000 << "ms." << std::endl;
//
//    return 1;
//}
//
//int
//UE::SCertVerifyforSwith(element_t Q1i, element_t Q2i, element_t V2i, element_t Sign4Others_i, Sateillite &sateillite2) {
//
//    system_clock::time_point begintime, endtime;
//    std::cout << "UESCertVerifyforSwith\t";
//    begintime = system_clock::now();
//
//    element_t Sign4Self_inv, Sign4Others_inv;
//    element_init_Zr(Sign4Self_inv, pairing);
//    element_init_Zr(Sign4Others_inv, pairing);
//
//    unsigned char Q1i_string[element_length_in_bytes(Q1i)];
//    unsigned char Q2i_string[element_length_in_bytes(Q2i)];
//    unsigned char V2i_string[element_length_in_bytes(V2i)];
//    unsigned char m2i_string[element_length_in_bytes(sateillite2.m)];
//
//    element_to_bytes(Q1i_string, Q1i);
//    element_to_bytes(Q2i_string, Q2i);
//    element_to_bytes(V2i_string, V2i);
//    element_to_bytes(m2i_string, sateillite2.m);
////
////    string Q1i_string_;
////    string Q2i_string_;
////    string V2i_string_;
////    string m2i_string_;
////    Q1i_string_ = MyMd5::bufferToString(Q1i_string,element_length_in_bytes(Q1i));
////    Q2i_string_ = MyMd5::bufferToString(Q2i_string,element_length_in_bytes(Q2i));
////    V2i_string_ = MyMd5::bufferToString(V2i_string,element_length_in_bytes(V2i));
////    m2i_string_ = MyMd5::bufferToString(m2i_string,element_length_in_bytes(sateillite2.m));
////
////    Q1i_string_ = MyMd5::MD5(Q1i_string_);
////    Q2i_string_ = MyMd5::MD5(Q2i_string_);
////    V2i_string_ = MyMd5::MD5(V2i_string_);
////    m2i_string_ = MyMd5::MD5(m2i_string_);
//
//    std::string temp = Utils::myxor((const char *) Q2i_string, (const char *) m2i_string);
//    temp = Utils::myxor(temp, (const char *) V2i_string);
//    element_from_hash(Sign4Self_inv, (void *) temp.c_str(), temp.length());
//
//
//    unsigned char Sign_string[element_length_in_bytes(Sign4Self_inv)];
//    element_to_bytes(Sign_string, Sign4Self_inv);
//
////    string Sign_string_;
////    Sign_string_ = MyMd5::bufferToString(Sign_string,element_length_in_bytes(Sign4Self_inv));
////    Sign_string_ = MyMd5::MD5(Sign_string_);
//
//    temp = Utils::myxor((const char *) Q1i_string, (const char *) Sign_string);
////    temp = Utils::myxor((const char *)Q1i_string,temp);
//    element_from_hash(Sign4Others_inv, (void *) temp.c_str(), temp.length());
//
////    int s=0,f=0;
//
//    bool isVerify = !element_cmp(Sign4Others_i, Sign4Others_inv);
//    if (isVerify) {
//        std::cout << "UE Verification for Switch Satellite Succeed!" << std::endl;
////        s++;
//        isverify = 1;
//    } else {
//        std::cout << "UE Verification for Switch Satellite Failure!" << std::endl;
////        f++;
//    }
////    std::cout << "Succeed UEs:"<< s<<".\t"<<"Failure UEs:"<< f <<"."<<std::endl;
//
//    endtime = system_clock::now();
//    double clock_UESCertVerifyforSwich;
//    clock_UESCertVerifyforSwich = duration<double, milli>(endtime - begintime).count();
//    std::cout << clock_UESCertVerifyforSwich * 1000 << "ms." << std::endl;
//
//    return 1;
//}

















#define UE_BATCH_CUR_TIME_COST_LABEL "UEN current batch authorisation time:"
#define UE_BATCH_UEI_CUR_TIME_COST_LABEL "UEI current batch authorisation time:"
#define UE_BATCH_UEI_AVG_TIME_COST_LABEL "UEI average batch authorisation time:"
#define UE_BATCH_UEI_WST_TIME_COST_LABEL "UEI worst batch authorisation time:"



,
        lb_ue_batch_uei_cur_time_cost{"Certificate Verify Time(ms)", "Communication Time(ms)",
                                      "Total Time Cost(ms)"},
        lb_ue_batch_uei_avg_time_cost{"Total Number of UEI", "Certificate Verify Time(ms)", "Communication Time(ms)",
                                      "Total Time Cost(ms)"},
        lb_ue_batch_uei_wst_time_cost{"Certificate Verify Time(ms)", "Communication Time(ms)",
                                      "Total Time Cost(ms)"},
        lb_ue_batch_cur_time_cost{"Poly Time(ms)", "Certificate Verify Time(ms)", "Communication Time(ms)",
                                  "Total Time Cost(ms)"}